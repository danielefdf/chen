
VERSIONI:
 * 1004 : base
 * 1005 : KO
 * 1006 : KO spostare perftCountersDebug in Utilities
 * 1007 : KO spostare costanti da Node a Engine
 * 1008 : KO eliminare engine da node
 * 1009 : riparto da 1004: spostare tutti i debug in Utilities
 * 1010 : spostare costanti relative all'array mosse da Node a Engine
 * 1011 : spostare costanti relative alle mosse del gioco da Node a Game
 * 1012 : le classi senza costruttore ora sono abstract: Evaluation/EvaluaShow
 *        MoveRecord spostato in View
 * 1013 : Search deve essere statica
 *        movesEngine diventa membro statico della nuova classe Engines
 *        costanti per threefold repetition spostate da Utilities a Engine
 * 1014 : eliminare valorizzazioni con default in Game, e gestire dei costruttori statici
 * 1015 : eliminare valorizzazioni con default in Engine, e gestire dei costruttori statici
 *        deve esserci un defaultEngine sempre uguale, non con un nome diverso ogni volta
 * 1016 : eliminare engine da node
 * 1017 : KO - tentativo di: spostare le mosse in engine, eliminandole da Node
 * 1018 : evaluation in Engine
 * 1019 : evaluashow in Engine
 * 1020 : no statics in Engine
 * 1021 : search in Engine
 *        tutti gli elementi del package model.search in model.engine
 * 1022 : eliminare campo engine da Engine
 * 1023 : spostare le mosse in engine, eliminandole da Node
 *        eliminare NodeBackup
 * 1024 : razionalizzare MOVES_ENGINE: non più come unica istanza statica in Engines
 *            ogni classe ne avrà uno statico -- si rischiano collisioni
 *        eliminare prefissi Engine. in Engine
 *        fix vari
 * 1025 : miglioramenti longMoves
 *         - aumentato spazio per value (max value stimato)
 *         - eliminato segno: non può essere negativo
 * 1026 : ->Engine ->node.computeBoardQuantities();
 *        ->Engine ->node.computeSideQuantities(node.playerColor);
 *        ok
 * 1027 : miglioramenti struttura GameStage
 *        sistemare problemi forse connessi
 *         - EvsE: ogni tanto non fa la mossa e lascia scadere il tempo, in un game
 *         - HvsE: si blocca la partita, o forse la ricerca
 *         - Hvs*: help non va
 *        sistemare GameBackground come GameStage
 *        utilizzo help ferma aggiornamento clocks
 * 1028 : rifatti un po' di test
 *        visto che la velocità non è aumentata molto, ripristino le classi
 *        statiche Evalua****, perché decisamente più semplici da gestire
 * 1031 : eliminate verifiche per classe negli equals
 *        consolidamento background
 * 1033 : sistemata referenza errata a classe Engine per campi EvaluaShow (!)
 *        campi in millis ora sono Long
 * 1034 : separati meglio campi Utilities vs ViewUtilities
 *            ora è possibile ad es cancellare tutti i package view.* e il resto funziona,
 *            dopo aver adeguato il main, chiaramente
 * 1035 : calcolo esistenza di almeno una mossa per perft -- calcolo matto/stallo
 * 1036 : il valore non serve in PV, passo da LongMove a intMove
 * 1037 : eliminazione flag castling --> boolean
 * 1038 : tornato indietro rispetto ad una modifica fatta precedentemente, perché
 *        in alcuni casi i campi *millis formato Long danno strani problemi
 * 1039 : riduzione dimensione campi - parte 1 -- model e conseguenti
 * 1040 : riduzione dimensione campi - parte 2
 * 1041 : sistemazione problema playVariation
 * 1042 : reimpostazione gestione parametri engine
 * 1043 : separazione classi in package controller; utilities -> model.utilities
 * 1044 : interfaccia per engine -> ok ma rifaccio per strutturare meglio
 * 1045 : logica controller anche per view.evaluation -> OK
 * 1046 : IntelliJ Base
 * 1047 : IntelliJ Base (2)
 * 1048 : eliminata registrazione PV, history e killer in QS
 * 1049 : inseriti inline-if e eliminati utilizzi di initAlpha
 * 1050 : modifica registrazione in tMap, eliminato +1 in heuristic e altri aggiustamenti IntelliJ
 * 1051 : inclusione Evaluation in Engine (EvaluaShow resta distaccata)
 * 1052 : KO: eliminazione elementi JavaFx (tranne che per threads: sono ben strutturati quelli JavaFx)
 *         + registrazione tempo partita
 *         + impostazione UCI
 *         + separati i package notations e figures
 *         + ripristinato Motif

 da qui diventa analphabetaX

 * 0100 : KO: varie
 * 0101 : ripristino JavaFx
        : note razionalizzate
        : razionalizzazione nomi notazioni Pan San Fen
        : frequency -> period
        : delayedmatecheck
        : initgametables
        : elementi static di game spostati in engine
        : input searchlength
        : numeri primi a caso sostituiti da potenze di 2
        : nuovo parametro delayedmatecheck
        : eliminati draw e resign da parte del motore
        : ripristino LongMoves, al momento deprecata
        : inserita profondità nella valutazione
        : pulizia warning per views
 * 0102 : riorganizzati Main
        : sostituito treelevel con searchdepth nella valutazione
            Non funziona: con le ricerche aggiuntive perde il valore corretto, e restituisce la mossa sbagliata.
            Ad es. per searchDepth = 3 chiama pvSearch(node, 3, ... ) , poi pvSearch(node, 2, ... ), poi pvSearch(node, 1, ... )
                ma se c'è uno scacco chiama di nuovo pvSearch(node, 1, ... ), invece di pvSearch(node, 0, ... ).
            Idem per la ricerca quiescente.
            * sostituisco questo schema:
                private Integer pvSearch(final Node focusNode, final int searchDepth, final int initAlphaValue, final int initBetaValue)
                                nextNodeValue = pvSearch(focusNode, searchDepth - 1, -betaValue, -alphaValue);
            * con questo schema:
                private Integer pvSearch(final Node focusNode, final int searchDepth, final int initAlphaValue, final int initBetaValue)
                                nextNodeValue = pvSearch(focusNode, searchDepth + 1, -betaValue, -alphaValue);
                Si parte con pvSearch(startNode, 0, ALPHA, BETA) e si incrementa ad ogni chiamata.
                Il valore per cui deve chiaare heuristic invece di proseguire deve essere però registrato.
                Inoltre è necessario gestire l'approfondimento per scacco, dato che bisognerà confrontare searchDepth
                        con reqSearchDepth + 1 invece che con 0.
        : MAX_MOVES che avevo unificato, significa in realtà due cose diverse:
            numero mosse nella posizione
            numero mosse nel gioco
 * 0103 : eliminata verifica di best/worst alfa/beta
        : sistemato problema in registrazione in tMap
        : rinominati focusNode>node value>score alphavalue>alpha betavalue>beta
 * 0106 : perft separato dal resto; eliminato parametro debug
        : eliminato parametro nodeindentstring: sempre attivo per
        : eliminato parametro arrocchi nella ricerca quiescente
        : sistemata (credo) registrazione nella history heuristic
        : sistemazioni (credo) registrazione tmap
        : quiescenceSearchWithCheck chiamava quiescenceSearch
        : searchtimeout() inlined
        : funzioni nextMove riunite
        : sistemata visualizzaizone bitboards rings
        : corretto valore di knight tra i valori di king
        : sistemati alcuni valori per punteggi
 * 0107 : KO
 * 0108 : eliminazione level in tRec
        : creata classe EngineSearchTrace
 * 0109 : KO registrazione pvmap con depth: necessita iter di tMap
 * 0110 : KO allora uso direttamente tMap, ma non sembra funzionare: con depth si perdono le pv
        : Dato che uso iterative deepening, non dovrebbe essere un problema la replace sempre







